using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Boggle
{
    /// <summary>
    /// Implements the neccessary logic for solving all words on a Boggle grid.
    /// </summary>
    public class Solver : ISolver
    {
        private HashSet<string> words;

        public Solver(HashSet<string> words)
        {
            this.words = words;
        }

        public IResults FindWords(char[,] board)
        {
            Results results = new Results();

            results.SetWords(GetAllWords(board));

            // Score the words
            foreach(var word in results.Words)
            {
                results.AddScore(GetScoreForWord(word));
            }

            return results;
        }

        /// <summary>
        /// Iterates over each character in the board, and returns all the words that can be found starting at these characters
        /// </summary>
        private List<string> GetAllWords(char[,] board)
        {
            HashSet<string> foundWordCache = new HashSet<string>();
            List<string> returnList = new List<string>();

            for (int i = 0; i < board.GetLength(0); i++)
            {
                for(int j = 0; j < board.GetLength(1); j++)
                {
                    HashSet<Tuple<int,int>> visitedNodes = new HashSet<Tuple<int, int>>(); // Temporary lock on the characters in the board already visited

                    foreach (var word in GetWord(i,j,board, "", visitedNodes, foundWordCache))
                    {
                        returnList.Add(word);
                    }
                }
            }

            return returnList;
        }

        /// <summary>
        /// Recursive backtracking co-routine method, yields the return for every found word. Words are generated by appending each character in every
        /// direction of the board to a string accumulator. Once an acceptable word is found, it is returned to the caller.
        /// </summary>
        private IEnumerable<string> GetWord(int row, int col, char[,] board, string currWord, HashSet<Tuple<int, int>> visitedNodes, HashSet<string> foundWordCache)
        {
            // We visited this node, don't return here again
            visitedNodes.Add(new Tuple<int, int>(row, col));

            string c = board[row, col].ToString();

            // 'q' represents 'qu' in Boggle, since q is almost ubiquitously followed by a u
            if(c == "q")
            {
                currWord += "qu";
            }
            else
            {
                currWord += c;
            }
            
            if(!foundWordCache.Contains(currWord) && IsScoredBoggleWord(currWord))
            {
                foundWordCache.Add(currWord);

                yield return currWord;
            }

            // Try all board directions
            for(int i = -1; i <= 1; i++)
            {
                for(int j = -1; j <= 1; j++)
                {
                    if (!visitedNodes.Contains(new Tuple<int, int>(row + i, col + j)) && PointIsInBounds(row + i, col + j, board))
                    {
                        foreach (var word in GetWord(row + i, col + j, board, currWord, visitedNodes, foundWordCache))
                        {
                            yield return word;
                        }
                    }
                }
            }

            // Recursive backtrack, remove the node "lock"
            visitedNodes.Remove(new Tuple<int, int>(row, col));
        }

        /// <summary>
        /// Ensures that the position specified is withing the boundaries of the board
        /// </summary>
        private bool PointIsInBounds(int row, int col, char[,] board)
        {
            return (row < board.GetLength(0) && row >= 0 && col < board.GetLength(1) && col >= 0);
        }

        /// <summary>
        /// Returns true if the input word is an accepted word of the dictionary as well as all other constraints set by Boggle
        /// </summary>
        private bool IsScoredBoggleWord(string word)
        {
            if(word.Length < 3)
            {
                return false;
            }

            if (!words.Contains(word.ToUpper()))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Points are defined by the rules of Boggle
        /// </summary>
        private int GetScoreForWord(string word)
        {
            if(word.Length < 3)
            {
                return 0;
            }

            if(word.Length == 3 || word.Length == 4)
            {
                return 1;
            }

            if(word.Length == 5)
            {
                return 2;
            }

            if(word.Length == 6)
            {
                return 3;
            }

            if(word.Length == 7)
            {
                return 5;
            }

            if(word.Length >= 8)
            {
                return 11;
            }

            return 0;
        }
    }
}
